#!/usr/bin/env python3
# Python3 script to enforce dark mode in GNOME for GTK and Qt apps

import os
from subprocess import call
from pathlib import Path

# Some sane defaults
themeName = 'Adwaita'
iconThemeName = 'Adwaita'

# Set the users Home directory
_home = Path.home().__str__()
_themesHomeDir = Path(f"{_home}/.themes")
_iconsHomeDir = Path(f"{_home}/.icons")
_configHomeDir = Path(f"{_home}/.config")
_localShareDir = Path(f"{_home}/.local/share")

# create the home directories if needed.
if not _themesHomeDir.exists():
    os.mkdir(_themesHomeDir)
if not _iconsHomeDir.exists():
    os.mkdir(_iconsHomeDir)
if not _configHomeDir.exists():
    os.mkdir(_configHomeDir)


PATHS = {
    "home": {
        "config": _configHomeDir,
        "themes": _themesHomeDir,
        "icons": _iconsHomeDir
    },
    "share": {
        "localIcons": Path(f"{_localShareDir}/themes"),
        "localThemes": Path(f"{_localShareDir}/themes"),
        "usrThemes": Path("/usr/share/themes"),
        "usrIcons": Path("/usr/share/icons")
    }
}


def PrintLog(msg: str = "", symbol: str = "*", consoleWidth: int = 80):
    if (msg != ""):
        print(
            f"[{symbol}] {msg}" +
            f"".join([" " for i in range(consoleWidth-len(msg))]) +
            f"[{symbol}]"
        )


def CheckPathByStructure(p: Path = _home, dirChecks: list[Path] = [], fileChecks: list[Path] = []) -> bool:
    PrintLog(f"Checking {p} folder structure")

    results = [
        *[{"path": path, "result": path.is_dir()} for path in dirChecks],
        *[{"path": path, "result": path.is_file()} for path in fileChecks]
    ]
    failedTests = [
        result
        for result
        in results
        if result["result"] == False
    ]

    return len(failedTests) == 0


def IsValidTheme(themePath: Path) -> bool:
    dirChecks = [
        Path(f"{themePath}/gtk-3.0"),
        Path(f"{themePath}/gtk-4.0"),
        Path(f"{themePath}/gnome-shell"),
    ]
    fileChecks = [
        Path(f"{themePath}/index.theme")
    ]
    return CheckPathByStructure(themePath, dirChecks, fileChecks)


def IsValidIconPack(iconPath: Path) -> bool:
    # Seems Icon pack definition is a little difficult
    # to nail down so the icon packs may not be accurate
    # TODO: Figure out Icon Pack Validation
    return CheckPathByStructure(iconPath, [], [Path(f"{iconPath}/index.theme")])


class GTKTheme:
    path: Path
    name: str

    # pyright: ignore[reportInvalidTypeForm]
    def __init__(self, path: Path, name: str):
        self.path = path
        self.name = name

    def __repr__(self) -> str:
        return f"GTKTheme(path='{self.path}', name='{self.name}')"

    def __str__(self) -> str:
        return self.name


def GetThemes() -> list[GTKTheme]:
    themes = []

    for themeName in os.listdir(PATHS["home"]['themes']):
        absPath = Path(f"{PATHS["home"]['themes']}/{themeName}")
        if (IsValidTheme(themeName)):
            themes.append(GTKTheme(absPath, themeName))
    for themeName in os.listdir(PATHS["share"]['localThemes']):
        absPath = Path(f"{PATHS["share"]['localThemes']}/{themeName}")
        if (IsValidTheme(absPath)):
            themes.append(GTKTheme(absPath, themeName))
    for themeName in os.listdir(PATHS["share"]['usrThemes']):
        absPath = Path(f"{PATHS["share"]['usrThemes']}/{themeName}")
        if (IsValidTheme(absPath)):
            themes.append(GTKTheme(absPath, themeName))
    return themes


def ParseInt(value: str, default=0):
    try:
        return int(value)
    except ValueError:
        return default


def UserInputValidNumber(min: int, max: int):
    choice = f"{min}-1"
    while (not (ParseInt(choice, min-1) >= min and ParseInt(choice, max+1) <= max)):
        choice = input("")
    return ParseInt(choice)


def chooseByNumber(prompt: str, choices: list[str]) -> int:
    """Requests input of a number from the user and returns the choice-1 under 
    the assumption that the developer will use the return value as an index 
    lookup for a data array

    Args:
        prompt (str): Prompt to show the user above the input
        choices (list[str]): list of string choices for the user to choose from

    Returns:
        int: index of choice from original array
    """
    choice: int = 0
    count = 1

    for option in choices:
        print(f"{count}: {option}")
    print(prompt)
    return UserInputValidNumber(1, len(choices)) - 1


def ChooseTheme() -> Theme:
    pass


# def GetUserInput(prompt: str, choices: list[str] = []) -> str:
#     val = ""
#     if len(choices) > 0:
#         while (choices.__contains__(val) == False):
#             PrintLog("Available Choices:")
#             for choice in choices:
#                 print(f" - {choice}")
#             print(f"\n{prompt}")
#             val = input("Please choose a valid choice from above: \n")
#         return val


# def GetThemeChoice(themesHomeDir: str) -> str:

#     val = ""
#     sharePath = Path("/usr/share/themes")
#     choices = [str(icon)
#                for icon in [*os.listdir(sharePath), *os.listdir(themesHomeDir)]]
#     while (val == ""):
#         if (len(choices) > 0):
#             val = GetUserInput("Choose the Shell Theme you would like to use.", [str(
#                 dir) for dir in [*os.listdir(sharePath), *os.listdir(themesHomeDir)]])
#         else:
#             PrintLog(
#                 f"You don't have any Themes in {themesHomeDir} or {sharePath}")
#             return val

#     return val


# def GetIconThemeChoice(iconsHomeDir) -> str:

#     val = ""
#     sharePath = Path("/usr/share/icons")
#     choices = [str(icon)
#                for icon in [*os.listdir(sharePath), *os.listdir(iconsHomeDir)]]
#     while (val == ""):
#         if (len(choices) > 0):
#             val = GetUserInput(
#                 "Choose the Icon Theme you would like to use.", choices)
#         else:
#             PrintLog(
#                 f"You don't have any Icons in {iconsHomeDir} or {sharePath}")
#             return val

#     return val


# def SetGsettings(themeName: str = "Adwaita", iconThemeName: str = "Adwaita", prefersDark: bool = True) -> int:

#     PrintLog("Setting GNOME Theme (GTK3+ GTK4)...")

#     prefersDarkStr = "prefer-light"
#     if (prefersDark):
#         prefersDarkStr = "prefer-dark"

#     returnCode = call(
#         f"gsettings set org.gnome.desktop.interface color-scheme '{prefersDarkStr}'", shell=True)
#     returnCode += call(
#         f"gsettings set org.gnome.desktop.interface gtk-theme \"{themeName}\"", shell=True)
#     returnCode += call(
#         f"gsettings set org.gnome.desktop.wm.preferences theme \"{themeName}\"", shell=True)
#     returnCode += call(
#         f"dconf write /org/gnome/shell/extensions/user-theme/name \"\'{themeName}\'\"", shell=True)
#     returnCode += call(
#         f"gsettings set org.gnome.desktop.interface icon-theme \"{iconThemeName}\"", shell=True)

#     return returnCode


# def LinkThemeAdwaita(themeDir: Path):
#     returnCode = 0
#     # Remove the current stylesheet and assets
#     rmDirs = [
#         Path(f"{PATHS['home']['config']}/gtk-4.0/assets")
#     ]

#     rmFiles = [
#         Path(f"{PATHS['home']['config']}/gtk-4.0/gtk.css"),
#         Path(f"{PATHS['home']['config']}/gtk-4.0/gtk-dark.css")
#     ]
#     themeDirs = [
#         Path(f"{themeDir}/gtk-4.0/assets")
#     ]

#     themeFiles = [
#         Path(f"{themeDir}/gtk-4.0/gtk.css"),
#         Path(f"{themeDir}/gtk-4.0/gtk-dark.css")
#     ]

#     rmCombined = [*rmDirs, *rmFiles]
#     themeCombined = [*themeDirs, *themeFiles]

#     os.removedirs(rmDirs)
#     for file in rmFiles:
#         os.remove(file)

#     for i, path in enumerate(rmCombined):
#         PrintLog(f"ln -sf \"{themeCombined[i]}\" \"{path}\"", "$")
#         call(f"ln -sf \"{themeCombined[i]}\" \"{path}\"", shell=True)

#     return returnCode


# def FixFlatpaks(themeName, themesHomeDir, iconsHomeDir) -> int:

#     PrintLog("Setting Theme for all Flatpaks via GTK_THEME env variable")
#     returnCode = call(
#         f"sudo flatpak override --env=GTK_THEME={themeName}", shell=True)

#     PrintLog("Sharing Theme Directories with all Flatpaks")
#     returnCode += call("sudo flatpak override --filesystem=/usr/share/themes", shell=True)
#     returnCode += call(
#         f"sudo flatpak override --filesystem={themesHomeDir}", shell=True)

#     PrintLog("Sharing Icon Directories with all Flatpaks")
#     returnCode += call(f"sudo flatpak override --filesystem=/usr/share/icons", shell=True)
#     returnCode += call(
#         f"sudo flatpak override --filesystem={iconsHomeDir}", shell=True)

#     PrintLog("Sharing xdg-config with all Flatpaks")
#     returnCode += call("sudo flatpak override --filesystem=xdg-config/gtk-3.0", shell=True)
#     returnCode += call("sudo flatpak override --filesystem=xdg-config/gtk-4.0", shell=True)

#     return returnCode


# def AddQtEnvVars(homeDir):
#     bash_profile = Path(f"{homeDir}/.bash_profile")
#     env_vars = [
#         "export QT_QPA_PLATFORMTHEME=qt5ct",
#         "export QT_QPA_PLATFORMTHEME=qt6ct"
#     ]

#     # Ensure the file exists
#     if not bash_profile.exists():
#         PrintLog("Checking .bash_profile for Qt Environment Vars")
#         with open(bash_profile, "w") as f:
#             pass  # Just create it

#     PrintLog("Checking .bash_profile for Qt Environment Vars")
#     with open(bash_profile, "r") as f:
#         lines = f.read().splitlines()

#     with open(bash_profile, "a") as f:
#         for env_var in env_vars:
#             if not any(env_var in line for line in lines):
#                 PrintLog(f"Adding: {env_var}")
#                 f.write(f"\n{env_var}\n")
#             else:
#                 print(f"[!] Already exists: {env_var}")
#     f.close()


# def FixQtApps(configHomeDir: str, themeName: str, iconThemeName: str, homeDir: str = Path.home()) -> int:

#     PrintLog("Creating Qt .config directories")
#     qt5ConfDir = Path(f"{configHomeDir}/qt5ct")
#     if (qt5ConfDir.exists() == False):
#         os.mkdir(qt5ConfDir)

#     qt6ConfDir = Path(f"{configHomeDir}/qt6ct")
#     if (qt6ConfDir.exists() == False):
#         os.mkdir(qt6ConfDir)

#     PrintLog("Creating Qt .config files")
#     qt5ConfFile = Path(f"{configHomeDir}/qt5ct/qt5ct.conf")
#     if (qt5ConfFile.exists() == False):
#         os.mkdir(qt5ConfFile)

#     qt6ConfFile = Path(f"{configHomeDir}/qt6ct/qt6ct.conf")
#     if (qt6ConfFile.exists() == False):
#         os.mkdir(qt6ConfFile)

#     qtConfigLines = [
#         "[Appearance]",
#         f"style={themeName}",
#         "color_scheme_path=",
#         f"icon_theme={iconThemeName}"
#     ]

#     # Write to qt5 config
#     PrintLog("Writing to Qt config files")
#     with open(qt5ConfFile, "w") as conf:
#         conf.writelines([f"{line}\n" for line in qtConfigLines])
#     conf.close()

#     # Write to qt6 config
#     with open(qt6ConfFile, "w") as conf:
#         conf.writelines([f"{line}\n" for line in qtConfigLines])
#     conf.close()

#     AddQtEnvVars(homeDir)


# def Main():

#     # Some sane defaults
#     themeName = 'Adwaita'
#     iconThemeName = 'Adwaita'

#     # Set the users Home directory

#     HOMEDIR = Path.home().__str__()

#     themesHomeDir = Path(f"{HOMEDIR}/.themes")
#     iconsHomeDir = Path(f"{HOMEDIR}/.icons")
#     configHomeDir = Path(f"{HOMEDIR}/.config")

#     # create the home directories if needed.
#     if (themesHomeDir.exists() == False):
#         os.mkdir(themesHomeDir)
#     if (iconsHomeDir.exists() == False):
#         os.mkdir(iconsHomeDir)

#     themeName = GetThemeChoice(themesHomeDir) or themeName
#     iconThemeName = GetIconThemeChoice(iconsHomeDir) or iconThemeName

#     PrintLog("Choices Made")
#     print(f"- {themeName=}")
#     print(f"- {themesHomeDir=}")
#     print(f"- {iconThemeName=}")
#     print(f"- {iconsHomeDir=}")

#     prefersDarkPrompt = GetUserInput(
#         f"Is {themeName} a dark theme?", ["y", "n"])
#     prefersDark = False
#     if prefersDarkPrompt == 'y':
#         prefersDark = True

#     # Fixing Gnome Apps
#     SetGsettings(themeName, iconThemeName, prefersDark)

#     # Fixing Qt Apps
#     FixQtApps(configHomeDir, themeName, iconThemeName, HOMEDIR)

#     # Fixing Flatpaks
#     needsFlatpakPrompt = GetUserInput(
#         f"Do you need to fix flatpak theming?", ["y", "n"])
#     needsFlatpak = False
#     if needsFlatpakPrompt == 'y':
#         needsFlatpak = True
#     if needsFlatpak:
#         FixFlatpaks(themeName, themesHomeDir, iconsHomeDir)


# if (__name__ == "__main__"):
#     Main()
